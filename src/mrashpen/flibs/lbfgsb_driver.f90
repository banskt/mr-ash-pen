module lbfgsb_driver
    use env_precision
    use global_parameters
    use futils, only: softmax, softmax_gradient
    implicit none
!
contains
!
!   This module contains subroutines for performing L-BFGS-B minimization.
!   It is invoked by the following command:
!
!       call setulb ( nopt, m, xopt, lbd, ubd, nbd, obj, grad, factr, pgtol, &
!                     wa, iwa, task, iprint, csave, lsave, isave, dsave )
!   
!       --------------------------------------------------------------
!               DESCRIPTION OF THE VARIABLES IN L-BFGS-B
!       --------------------------------------------------------------
!
!       nopt is an INTEGER variable that must be set by the user to the
!           number of variables.  It is not altered by the routine.
!
!       m is an INTEGER variable that must be set by the user to the
!           number of corrections used in the limited memory matrix.
!           It is not altered by the routine.  Values of m < 3  are
!           not recommended, and large values of m can result in excessive
!           computing time. The range  3 <= m <= 20 is recommended.
!
!       xopt is a DOUBLE PRECISION array of length `nopt`.  On initial entry
!           it must be set by the user to the values of the initial
!           estimate of the solution vector.  Upon successful exit, it
!           contains the values of the variables at the best point
!           found (usually an approximate solution).
!
!       lbd is a DOUBLE PRECISION array of length `nopt` that must be set by
!           the user to the values of the lower bounds on the variables. If
!           the i-th variable has no lower bound, lbd(i) need not be defined.
!
!       ubd is a DOUBLE PRECISION array of length `nopt` that must be set by
!           the user to the values of the upper bounds on the variables. If
!           the i-th variable has no upper bound, ubd(i) need not be defined.
!
!       nbd is an INTEGER array of dimension `nopt` that must be set by the
!           user to the type of bounds imposed on the variables:
!           nbd(i)=0 if xopt(i) is unbounded,
!                  1 if xopt(i) has only a lower bound,
!                  2 if xopt(i) has both lower and upper bounds,
!                  3 if xopt(i) has only an upper bound.
!
!       obj is a DOUBLE PRECISION variable.  If the routine setulb returns
!           with task(1:2)= 'FG', then `obj` must be set by the user to
!           contain the value of the function at the point `xopt`.
!
!       grad is a DOUBLE PRECISION array of length `nopt`.  
!           If the routine setulb returns with taskb(1:2)= 'FG', 
!           then `grad` must be set by the user to contain 
!           the components of the gradient at the point `xopt`.
!
!       factr is a DOUBLE PRECISION variable that must be set by the user.
!           It is a tolerance in the termination test for the algorithm.
!           The iteration will stop when
!
!               (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
!
!           where 
!           f = obj
!           epsmch is the machine precision which is automatically
!           generated by the code. Typical values for factr on a computer
!           with 15 digits of accuracy in double precision are:
!           factr=1.d+12 for low accuracy;
!                 1.d+7  for moderate accuracy;
!                 1.d+1  for extremely high accuracy.
!           The user can suppress this termination test by setting factr=0.
!
!       pgtol is a double precision variable.
!           On entry pgtol >= 0 is specified by the user.  The iteration
!           will stop when
!
!               max{|proj grad_i | i = 1, ..., nopt} <= pgtol
!
!           where pg_i is the ith component of the projected gradient.
!           The user can suppress this termination test by setting pgtol=0.
!
!       wa is a DOUBLE PRECISION  array of length
!           (2mmax + 5)nmax + 11mmax^2 + 8mmax used as workspace.
!           This array must not be altered by the user.
!           nmax = max of nopt, mmax = max of m
!
!       iwa is an INTEGER  array of length 3nmax used as
!           workspace. This array must not be altered by the user.
!           nmax = max of nopt
!
!       task is a CHARACTER string of length 60.
!           On first entry, it must be set to 'START'.
!           On a return with task(1:2)='FG', the user must evaluate the
!               function `obj` and gradient `grad` 
!               at the returned value of `xopt`.
!           On a return with task(1:5)='NEW_X', an iteration of the
!               algorithm has concluded, and `obj` and `grad` 
!               contain obj(xopt) and grad(xopt) respectively.
!               The user can decide whether to continue or stop
!               the iteration.
!           When
!           task(1:4)='CONV',
!               the termination test in L-BFGS-B has been
!                satisfied;
!           task(1:4)='ABNO', 
!               the routine has terminated abnormally
!               without being able to satisfy the termination conditions,
!               `xopt` contains the best approximation found,
!               `obj` and `grad` contain obj(xopt) and grad(xopt) respectively;
!           task(1:5)='ERROR',
!               the routine has detected an error in the
!               input parameters;
!           On exit with task = 'CONV', 'ABNO' or 'ERROR', the variable task
!           contains additional information that the user can print.
!           This array should not be altered unless the user wants to
!           stop the run for some reason.  See driver2 or driver3
!           for a detailed explanation on how to stop the run
!           by assigning task(1:4)='STOP' in the driver.
!
!       iprint is an INTEGER variable that must be set by the user.
!           It controls the frequency and type of output generated:
!               iprint<0    no output is generated;
!               iprint=0    print only one line at the last iteration;
!               0<iprint<99 print also f and |proj g| every iprint iterations;
!               iprint=99   print details of every iteration except n-vectors;
!               iprint=100  print also the changes of active set and final x;
!               iprint>100  print details of every iteration including x and g;
!           When iprint > 0, the file iterate.dat will be created to
!                          summarize the iteration.
!
!       csave  is a CHARACTER working array of length 60.
!
!       lsave is a LOGICAL working array of dimension 4.
!           On exit with task = 'NEW_X', the following information is
!           available:
!               lsave(1) = .true.  the initial `xopt` 
!                                  did not satisfy the bounds;
!               lsave(2) = .true.  the problem contains bounds;
!               lsave(3) = .true.  each variable has upper and lower bounds.
!
!       isave is an INTEGER working array of dimension 44.
!           On exit with task = 'NEW_X', it contains information that
!           the user may want to access:
!               isave(30) = the current iteration number;
!               isave(34) = the total number of function and gradient
!                           evaluations;
!               isave(36) = the number of function value or gradient
!                           evaluations in the current iteration;
!               isave(38) = the number of free variables in the current
!                           iteration;
!               isave(39) = the number of active constraints at the current
!                           iteration;
!
!           see the subroutine setulb.f for a description of other
!           information contained in isave
!
!       dsave is a DOUBLE PRECISION working array of dimension 29.
!           On exit with task = 'NEW_X', it contains information that
!           the user may want to access:
!               dsave(2)  = the value of f at the previous iteration;
!               dsave(5)  = the machine precision epsmch generated by the code;
!               dsave(13) = the infinity norm of the projected gradient;
!
!           see the subroutine setulb.f for a description of other
!           information contained in dsave
!
!       --------------------------------------------------------------
!             END OF THE DESCRIPTION OF THE VARIABLES IN L-BFGS-B
!       --------------------------------------------------------------
!
    subroutine min_plr_shrinkop(n, p, X, y, k, t, w, s2, sgrid,                &
                                nopt, is_topt, is_wopt, is_s2opt,              &
                                smlb, m, iprint, factr, pgtol,                 &
                                maxiter, maxfev,                               &
                                topt, wopt, s2opt, obj, grad, nfev, niter,     &
                                task)

!   
!   This subroutine uses L-BFGS-B to minimize the objective function,
!
!       obj = ||y - XM(t)||^2 + \sum_j P(M(t_j))
!
!   where P(.) is the penalty operator and M(.) is the shrinkage operator
!   for a given linear regression problem:
!
!       y = Xb + e
!       b ~ g(.)
!   
!   where g(.) is the prior distribution of a scale mixture of normals.
!
!       --------------------------------------------------------------
!               DESCRIPTION OF THE VARIABLES IN PLR-SHRINKOP
!       --------------------------------------------------------------
!
!       n is an INTEGER variable; the number of samples in y.
!           It is not altered by the routine.
!
!       p is an INTEGER variable; the number of 
!           explanatory variables (covariates) in the linear regression.
!           It is not altered by the routine.
!
!       X is a DOUBLE PRECISION array of size (n, p) that contains 
!           the explanatory variables (covariates) of the regression.
!           This is set by the user and is not normalized or centered
!           within the subroutine.
!           It is not altered by the routine.
!
!       y is a DOUBLE PRECISION array of size (n) that 
!           contains the response vector of the regression.
!           It is not altered by the routine.
!
!       k is an INTEGER variable; number of components 
!           in the scale mixture of Gaussians.
!           It is not altered by the routine.
!
!       t is a DOUBLE PRECISION array of size p.
!           On entry, it must be set by the user to contain
!           an initial guess for t (theta), such that M(t) = b
!           On exit, contains optimized value for t.
!           Note this is not the coefficients of regression,
!           which can then be obtained using b = M(t).
!
!       w is a DOUBLE PRECISION array of size k.
!           On entry, it must be set by the user to contain
!           an initial guess for coefficients in the
!           scale mixture of Gaussians.
!           On exit, it contains the optimized values for w.
!
!       s2 is a DOUBLE PRECISION variable.
!           On entry, it must contain the initial guess 
!           for variance of the likelihood of the regression,
!               s2 = Var(e) 
!
!       sgrid is a DOUBLE PRECISION array;
!           standard deviation of components in the 
!           scale mixture of Gaussians
!           It is not altered by the routine.
!
!       nopt is an INTEGER variable;
!           total number of parameters being optimized,
!           see description of variables in L-BFGS-B. 
!           It is not altered by the routine.
!
!       is_topt is a LOGICAL variable, whether to optimize t.
!
!       is_wopt is a LOGICAL variable, whether to optimize w.
!
!       is_s2opt is a LOGICAL variable, whether to optimize s2.
!
!       smlb is a DOUBLE PRECISION variable; the log-base of the 
!           softmax parametrization of w.
!               w_k = e^(smlb * a_k) / sum(e^(smlb * a_k))
!           Generally smlb = 1.
!
!       m, iprint, factr, pgtol
!           are used in the L-BFGS-B routine.
!           See above for a description of variables in L-BFGS-B.
!
!       maxiter is an INTEGER to specify the maximum number 
!           of iterations allowed in the L-BFGS-B driver.
!
!       maxfev is an INTEGER to specify the maximum number
!           of function and gradient evaluations
!           by the L-BFGS-B routine.
!           Often, each iteration requires multiple function and
!           gradient evaluations, so it is generally greater than
!           the value of `maxiter`.
!
!       --------------------------------------------------------------
!           END OF THE DESCRIPTION OF THE VARIABLES IN PLR-SHRINKOP
!       --------------------------------------------------------------
!
!
!
        use plr_mrash 
        implicit none
!
!       input variables
!
        integer(i4k), intent(in)      :: n, p, k
        integer(i4k), intent(in)      :: nopt, m, iprint
        integer(i4k), intent(in)      :: maxiter, maxfev
        real(r8k), intent(in)         :: X(n, p), y(n)
        real(r8k), intent(in)         :: sgrid(k)
        real(r8k), intent(in)         :: t(p), w(k), s2
        real(r8k), intent(in)         :: smlb
!       real(r8k), parameter          :: factr  = 1.0d+7, pgtol  = 1.0d-5
        real(r8k), intent(in)         :: factr, pgtol
        logical, intent(in)           :: is_topt, is_wopt, is_s2opt
        real(r8k), intent(out)        :: topt(p), wopt(k), s2opt
        real(r8k), intent(out)        :: obj
        real(r8k), intent(out)        :: grad(nopt)
        integer(i4k), intent(out)     :: nfev, niter
        character(len=60), intent(out) :: task
!
!       variables used in this subroutine
!
        real(r8k), dimension(nopt)    :: xopt
        real(r8k)                     :: tgrad(p), wgrad(k), s2grad, agrad(k)
        real(r8k)                     :: a(k)
        real(r8k)                     :: X2(n, p), dj(p), djinv(p)
        integer(i4k), dimension(nopt) :: nbd
        integer(i4k)                  :: t_nbd(p), w_nbd(k)
        real(r8k), dimension(nopt)    :: lbd, ubd
        character(len=60)             :: csave
        real(r8k), allocatable        :: wa(:)
        integer(i4k), allocatable     :: iwa(:)
        logical                       :: lsave(4)
        integer                       :: isave(44)
        real(r8k)                     :: dsave(29)
        integer(i4k)                  :: i
!
        allocate ( iwa(3*nopt) )
        allocate ( wa(2*m*nopt + 5*nopt + 11*m*m + 8*m) )
!
!       Bounds: There is only a lower bound on sigma^2
!       All other parameters are unbounded
!      
        t_nbd = 0
        w_nbd = 0
        call combine_integer_parameters(nbd, t_nbd, w_nbd, 1, is_topt, is_wopt, is_s2opt)
        if (is_s2opt) then
            lbd(nopt) = d_one * 1.0d-8
        end if
!
!       Convert w to softmax parameters a
!
        do i = 1, k
            if (w(i) /= 0) then
                a(i) = log(w(i)) / smlb
            else
                a(i) = -20 / smlb
            end if
        end do
!
!       `xopt` is the array of variables to be optimized
!       On entry, it contains the initial guess for t, a and s2
        call combine_parameters(xopt, t, a, s2, is_topt, is_wopt, is_s2opt)
!
!       Precalculate dj and 1/dj
!
        X2 = X ** d_two
        dj = sum(X2, 1)
        do i = 1, p
            djinv(i) = d_one / dj(i)
        end do
!       
!       The L-BFGS-B driver
!       
        task = 'START'
        do while(task(1:2).eq.'FG'.or.task.eq.'NEW_X'.or.task.eq.'START')
            call setulb ( nopt, m, xopt, lbd, ubd, nbd, obj, grad,            &
                           factr, pgtol, wa, iwa, task, iprint,               &
                           csave, lsave, isave, dsave )

            if (task(1:2) .eq. 'FG') then
!
!           -------------------------------------------------
!           The L-BFGS-B routine has returned to request the
!           objective `obj` and  gradients `grad
!           at the current value of `xopt`.
!           -------------------------------------------------
!           This is done using the following steps:
!               1. Split xopt to obtain t, a and s2.
                call split_parameters( xopt, topt, a, s2opt, is_topt, is_wopt, is_s2opt )
!
!               2. Obtain w = softmax(a)
                if (is_wopt) then
                    call softmax(a, smlb, wopt)
                end if
!
!               3. Use t, w and s2 to obtain objective and 
!                  gradients with respect to t, w and s2.
                call plr_obj_grad_shrinkop( n, p, X, y, topt, s2opt, k, wopt,  &
                                              sgrid, djinv,                    &
                                              obj, tgrad, wgrad, s2grad )
!
!               4. Obtain gradients w.r.t a from gradients w.r.t w
                if (is_wopt) then
                    call softmax_gradient( k, wopt, smlb, wgrad, agrad )
                end if
!
!               5. Combine the gradients to a single aray.
                call combine_parameters(grad, tgrad, agrad, s2grad, is_topt, is_wopt, is_s2opt)
!
            else if (task(1:5) .eq. 'NEW_X') then
!
!           -------------------------------------------------
!           The L-BFGS-B routine has returned with a new iterate.
!           At this point have the opportunity of stopping the iteration
!           or observing the values of certain parameters.
!           -------------------------------------------------
!           We implement two stopping criteria:
!               1. total number of iterations
                if (isave(30) .ge. maxiter)                                    &
                    task = 'STOP: TOTAL NO. of ITERATIONS REACHED LIMIT'
!
!               2. total number of function evaluations
                if (isave(34) .ge. maxfev)                                     &
                    task = 'STOP: TOTAL NO. of f AND g EVALUATIONS EXCEEDS LIMIT'
!           And print the information before termination.
!               isave(22)  the total number of intervals explored in the
!                          search of Cauchy points.
!               isave(26)  the total number of skipped BFGS updates before
!                          the current iteration.
!               isave(30)  the number of current iterations.
!               isave(33)  the number of intervals explored in the search of
!                          Cauchy point in the current iteration;
!               isave(34)  the total number of function and gradient evaluations.
!               isave(36)  the number of function and gradient
!                          evaluations in the current iteration;
!               isave(38)  the number of free variables in the current
!                          iteration.
!               isave(39)  the number of active constraints in the current
!                          iteration.
!
!
!               dsave(13) norm of the projected gradient
!               dsave(2)  last saved value of objective
!               
                if (task(1:4) .eq. 'STOP')                                     &
                    call prnstop( iprint, nopt, isave(30), isave(34),          &
                                  isave(22), isave(26), isave(39), dsave(13),  &
                                  obj, xopt, task)
            end if
        end do
        niter = isave(30)
        nfev  = isave(34)
    end subroutine
!
    subroutine split_parameters(x, t, a, s, is_topt, opt_a, opt_s)
!   
!   x = [t_1, t_2, ... t_p, a_1, a_2, ..., a_k, s]
!   This subroutine helps to split an array of DOUBLE PRECISION variables x
!   to its constituents: array t, array a, and variable s.
!       x contains t only if is_topt = .true.
!       x contains w only if is_wopt = .true.
!       x contains s only if opt_s = .true.
!   nparams is an INTEGER which contains the total number of variables in x.
!   p is an INTEGER; size of t
!   k is an INTEGER; size of a
!
        implicit none
        integer(i4k) :: p, k, iopt
        real(r8k)    :: x(:), t(:), a(:), s
        logical      :: is_topt, opt_a, opt_s
!
        p = size(t)
        k = size(a)
        iopt = 0 
        if (is_topt) then
            t = x(1:p)
            iopt = p
        end if
        if (opt_a) then
            a = x(iopt+1:iopt+k)
            iopt = iopt + k
        end if
        if (opt_s) then
            s = x(iopt+1)
        end if
    end subroutine

    subroutine combine_parameters(x, t, a, s, is_topt, opt_a, opt_s)
!   
!   x = [t_1, t_2, ... t_p, a_1, a_2, ..., a_k, s]
!   This subroutine helps to combine array t, array a, and variable s
!   to an array of DOUBLE PRECISION variables x.
!       x contains t only if is_topt = .true.
!       x contains w only if is_wopt = .true.
!       x contains s only if opt_s = .true.
!   nparams is an INTEGER which contains the total number of variables in x.
!   p is an INTEGER; size of t
!   k is an INTEGER; size of a
!
!   see combine_integer_parameters() for combining INTEGER variables.
!
        implicit none
        integer(i4k) :: p, k, iopt
        real(r8k)    :: x(:), t(:), a(:), s
        logical      :: is_topt, opt_a, opt_s
!
        p = size(t)
        k = size(a)
        iopt = 0 
        if (is_topt) then
            x(1:p) = t
            iopt = p
        end if
        if (opt_a) then
            x(iopt+1:iopt+k) = a
            iopt = iopt + k
        end if
        if (opt_s) then
            x(iopt+1) = s
        end if
    end subroutine

    subroutine combine_integer_parameters(x, t, a, s, is_topt, opt_a, opt_s)
!   
!   same as combine_parameters() but for INTEGER variables in t, a, s and x.
!
!   x = [t_1, t_2, ... t_p, a_1, a_2, ..., a_k, s]
!   This subroutine helps to combine array t, array a, and variable s
!   to an array of INTEGER variables x.
!       x contains t only if is_topt = .true.
!       x contains w only if is_wopt = .true.
!       x contains s only if opt_s = .true.
!   nparams is an INTEGER which contains the total number of variables in x.
!   p is an INTEGER; size of t
!   k is an INTEGER; size of a
!
        implicit none
        integer(i4k) :: p, k, iopt
        integer(i4k) :: x(:), t(:), a(:), s
        logical      :: is_topt, opt_a, opt_s
!
        p = size(t)
        k = size(a)
        iopt = 0 
        if (is_topt) then
            x(1:p) = t 
            iopt = p 
        end if
        if (opt_a) then
            x(iopt+1:iopt+k) = a 
            iopt = iopt + k 
        end if
        if (opt_s) then
            x(iopt+1) = s 
        end if
    end subroutine
!
    subroutine prnstop( iprint, n, iter, nfgv, nintol, nskip, nact,            &
                        sbgnrm, f, x, task)
!
        integer(i4k), intent(in) :: iprint, n, iter, nfgv, nintol, nskip, nact
        real(r8k), intent(in) :: f, sbgnrm, x(n)
        character(len=60), intent(in) :: task
        integer(i4k) :: i
!       
        if (iprint .ge. 0) then
            write (6,3003)
            write (6,3004)
            write (6,3005) n,iter,nfgv,nintol,nskip,nact,sbgnrm,f
            if (iprint .ge. 100) then
                write (6,1004) 'X =',(x(i),i = 1,n)
            endif
            if (iprint .ge. 1) write (6,*) ' F =',f
            write (6,3009) task
        end if
 1004 format (/,a4, 1p, 6(1x,d11.4),/,(4x,1p,6(1x,d11.4)))
 3003 format (/,                                                               &
      '           * * *',/,/,                                                  &
      'Tit   = total number of iterations',/,                                  &
      'Tnf   = total number of function evaluations',/,                        &
      'Tnint = total number of segments explored during',                      &
                ' Cauchy searches',/,                                          &
      'Skip  = number of BFGS updates skipped',/,                              &
      'Nact  = number of active bounds at final generalized',                  &
               ' Cauchy point',/,                                              &
      'Projg = norm of the final projected gradient',/,                        &
      'F     = final function value',/,/,                                      &
      '           * * *')
 3004 format (/,3x,'N',4x,'Tit',5x,'Tnf',2x,'Tnint',2x,                        &
              'Skip',2x,'Nact',5x,'Projg',8x,'F')
 3005 format (i5,2(1x,i6),(1x,i6),(2x,i4),(1x,i5),1p,2(2x,d10.3))
 3009 format (/,a60)
    end subroutine
!
end module
